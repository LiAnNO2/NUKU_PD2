#include <iostream>
#include<string>
#include<vector>
#include<fstream>
#include <algorithm>
#include <iterator>
    using namespace std;

    class keywords { // 紀錄並作為輸出
    public:
        vector<string> keyword;
        vector<int> yes;
    };


    vector<class keywords> key;
    vector<string> sentence; // 句子輸入
    vector<string> id;

    string change(string s); // 轉小寫和去掉非字母和控空格符號
    bool yon(vector<string>&mid, int k); // 判斷有沒有符合

    int main(int argc, char** argv) {

        // 測試時i的大小要調
        string h;
        for (int i = 0; i < 62; i++) {
            getline(cin, h);
            id.push_back(h.substr(0, h.find(",")));
            h = h.substr(h.find(",") + 1, h.length());
            sentence.push_back(change(h));
        }
        for (int i = 0; i < 10; i++) {  // 要切空白
            getline(cin, h);
            class keywords mid1;
            vector<string> ww;
            h = change(h);
            while (1) { // 切割
                if (h.find(" ") != -1) { // 避免沒有空格卻pushback兩次
                    ww.push_back(h.substr(0, h.find(" ")));
                    h = h.substr(h.find(" ") + 1, h.length());
                }

                if (h.find(" ") == -1) {
                    ww.push_back(h);
                    break;
                }
            }
            mid1.keyword = ww;
            key.push_back(mid1);
        }


        //test
        /*
        cout << endl;
        for (int i = 0; i < sentence.size(); i++) {
            cout << sentence[i] << endl;
        }
        for (int i = 0; i < key.size(); i++) {
            for (int j = 0; j < key[i].keyword.size(); j++) {
                cout << key[i].keyword[j] << " " << i << endl;
            }
        }
        */

        // 判斷
        for (int i = 0; i < sentence.size(); i++) {
            vector<string> mid; // 存字串

            while (1) { // 切割
                if (sentence[i].find(" ") != -1) {
                    mid.push_back(sentence[i].substr(0, sentence[i].find(" ")));
                    sentence[i] = sentence[i].substr(sentence[i].find(" ") + 1, sentence[i].length());
                }

                if (sentence[i].find(" ") == -1) {
                    mid.push_back(sentence[i]);
                    break;
                }
            }
            sort(mid.begin(), mid.end());
            auto result1 = unique(mid.begin(), mid.end());
            mid.resize(distance(mid.begin(), result1));

            for (int k = 0; k < key.size(); k++) {
                if (yon(mid, k)) {
                    key[k].yes.push_back(stoi(id[i]));
                }
            }
        }

        // 輸出
        for (int i = 0; i < key.size(); i++) {
            if (key[i].yes.size() == 0) {
                cout << "-1" << endl;
            }
            else {
                sort(key[i].yes.begin(), key[i].yes.end());
                for (int j = 0; j < key[i].yes.size(); j++) {
                    if (j == 0) {
                        cout << key[i].yes[j];
                    }
                    else {
                        cout << " " << key[i].yes[j];
                    }
                }
                cout << endl;
            }
        }

        return 0;
    }

    bool yon(vector<string>&mid, int k) {
        sort(key[k].keyword.begin(), key[k].keyword.end());
        auto result = unique(key[k].keyword.begin(), key[k].keyword.end());
        key[k].keyword.resize(distance(key[k].keyword.begin(), result));


        int time = key[k].keyword.size();
        int x = 0;
        for (int j = 0; j < mid.size(); j++) {
            for (int l = 0; l < time; l++) {
                if (mid[j].compare(key[k].keyword[l]) == 0) {
                    x++;
                    break;
                }
            }
            if (x == time) {
                return true;
            }
        }
        return false;
    }

    string change(string s) {
        string h;
        for (int i = 0; i < s.size(); i++) {
            if ('A' <= s[i] && s[i] <= 'Z') {
                h += s[i] + 'a' - 'A';
            }
            else if (('a' <= s[i] && s[i] <= 'z') || s[i] == ' ') {
                h += s[i];

            }
        }
        return h;
    }
